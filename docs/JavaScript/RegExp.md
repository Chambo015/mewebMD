Регулярные выражения – мощное средство поиска и замены в строке.  
Тип `RegExp` реализует в `ECMAScript` регулярные выражения, которые можно с легкостью создавать, используя синтаксис, похожий на `Perl`:

```js
let regexp = new RegExp("шаблон", "флаги");

// короткий синтаксис
let regexp = /шаблон/; // без флагов 
let regexp = /шаблон/gmi; // с флагами gmi
```
Слеши `/.../` говорят JavaScript о том, что это регулярное выражение.  
Основная разница между этими двумя способами создания заключается в том, что `/.../` не допускают никаких вставок переменных (наподобие `${...}`). Они полностью статичны.  
Слеши используются, когда мы на момент написания кода точно знаем, каким будет регулярное выражение. А `#!js new RegExp` – когда мы хотим создать регулярное выражение «на лету» из динамически сгенерированной строки, например:

```js 
let tag = prompt("Какой тег вы хотите найти?", "h2");

let regexp = new RegExp(`<${tag}>`); // то же, что /<h2>/ 
```

## Флаги
Каждое выражение может иметь или не иметь флаги, которые влияют на поиск.

флаг    |   Описание
--------|---------------
`i`     | С этим флагом поиск не зависит от регистра: нет разницы между `A` и `a`
`g`     | С этим флагом поиск ищет все совпадения, без него – только первое.
`m`     | С этим флагом учитывает все строки для начала и конца, без у всего текста один конец и начало
`y`     | Режим поиска на конкретной позиции в тексте
`u`     | Включает полную поддержку юникода. Флаг разрешает корректную обработку суррогатных пар
`s`     | Включает режим «dotall», при котором точка `.` может соответствовать символу перевода строки `\n`

## Методы
Использование регулярных выражений интегрировано в методы строк.
### Поиск: `#!js str.match(regexp)`
Метод `match()` возвращает получившиеся совпадения при сопоставлении строки с регулярным выражением.
Метод может вернуть 3 разных результата:

=== "с флагом `g`"

    Если у регулярного выражения есть флаг `g`, то он возвращает массив всех совпадений:

    ```JavaScript
    let str = "Любо, братцы, любо!";

    str.match(/любо/gi); // Любо,любо (массив из 2х подстрок-совпадений) (1)
    ```

    1.  Обратите внимание: найдены и `Любо` и `любо`, благодаря флагу `i`, который делает регулярное выражение регистронезависимым.

=== "Без флага `g`"

    Если такого флага нет, то возвращает только первое совпадение в виде массива, в котором по индексу `0` находится совпадение, и есть свойства с дополнительной информацией о нём:

    ```JavaScript
    let str = "Любо, братцы, любо!";

    let result = str.match(/любо/); // без флага g

    result[0]      // любо (первое совпадение)
    result.length  // 1

    // Дополнительная информация:
    result.index // 14 (позиция совпадения) (символ "л" в строке начинается с 14 индекса)
    result.input // Любо, братцы, любо! (исходная строка)
    ```
    ![regexp](https://sun9-20.userapi.com/impf/D2kSr9l-gvWoDNmgJDAV2XIxUBpbWYUsDnY_bw/PKXPgdsrUig.jpg?size=534x128&quality=95&sign=f9c23a2212152c6baa46f464d4a615c6&type=album)

=== "Если совпадений нет"

    Если совпадений нет, то, вне зависимости от наличия флага `g`, возвращается `null`.

    ```JavaScript
    let matches = "JavaScript".match(/HTML/); // = null

    if (!matches.length) { // Ошибка: у null нет свойства length
        alert("Ошибка в строке выше");
    }

    // Если хочется, чтобы результатом всегда был массив, можно написать так:
    let matches = "JavaScript".match(/HTML/) || [];

    if (!matches.length) {
        alert("Совпадений нет"); // теперь работает
    }
    ```

### Замена: `str.replace()`
Метод `str.replace(regexp, replacement)` заменяет совпадения с `regexp` в строке `str` на `replacement` (все, если есть флаг `g`, иначе только первое).

```JavaScript
// без флага g
"We will, we will".replace(/we/i, "I")  // I will, we will

// с флагом g
"We will, we will".replace(/we/ig, "I") // I will, I will
```
В строке замены `replacement` мы можем использовать специальные комбинации символов для вставки фрагментов совпадения:

Спецсимволы   |	Действие в строке замены
--------------|--------------------------
`$&`          |	вставляет всё найденное совпадение
<code>$&#096;</code>	        | вставляет часть строки до совпадения
`$'`          | вставляет часть строки после совпадения
`$n`          |	если n это 1-2 значное число, вставляет содержимое n-й скобочной группы регулярного выражения, больше об этом в главе Скобочные группы
`$<name>`     |	вставляет содержимое скобочной группы с именем name, также изучим в главе Скобочные группы
`$$`          |	вставляет символ "$"

Примеры

=== "`$&`"

    ```JavaScript
    "Я люблю HTML".replace(/HTML/, "$& и JavaScript")  // Люблю HTML и JavaScript
    ```

=== "<code>$&#096;</code>"

    ```JavaScript
    "Я люблю HTML".replace(/HTML/, "CSS и $` и JavaScript") 
    // 'Я люблю CSS и Я люблю  и JavaScript'
    ```

=== "`$'`"

    ```JavaScript
    "Я люблю HTML и CSS".replace(/HTML/, "$'") 
    // 'Я люблю  и CSS и CSS'
    ```    

### Проверка: `regexp.test()`
Метод `#!JavaScript regexp.test(str)` проверяет, есть ли хоть одно совпадение, если да, то возвращает `true`, иначе `false`.

```js
let str = "Я ЛюБлЮ JavaScript";
let regexp = /люблю/i;
        
regexp.test(str) // true
```

## Символьные классы
- `\d` – цифры.
- `\D` – не цифры.
- `\s` – пробельные символы, табы, новые строки.
- `\S` – все, кроме `\s`.
- `\w` – латиница, цифры, подчёркивание `_`.
- `\W` – все, кроме `\w`.
- `.` – любой символ, если с флагом регулярного выражения `s`, в противном случае любой символ, кроме перевода строки `\n`.
- `^` - начало текста
- `$` - конец текста  
    `^...$` - часто используются для проверки, совпадает ли строка с шаблоном полностью.
- `\b` - граница слова, как `^` и `$`.   
    :warning: Граница слова `\b` не работает для алфавитов, не основанных на латинице.

Примеры:
```js 
/\b\d{4}\b/.test(code), // ровно 4 цифры
/\b\d{4,6}\b/.test(code) // ровно от 4 до 6 цифр;
/\b[\da-z]{4,6}\b/.test(code) // ровно от 4 до 6 символов, которыми могут быть цифры либо маленькие латинские буквы;
/\b[\da-f]{7}\b/i.test(code) // ровно 7 шестнадцатеричных цифр (0123456789ABCDEF)
/^\d\w+$/i.test(code) // начинается с цифры и содержит произвольное количество цифр и латинских букв любого регистра(большие и маленькие).

```

![](https://www.exlab.net/files/tools/sheets/regexp/regexp.png)