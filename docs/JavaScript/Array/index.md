# Array
## Как лучше создавать массив?
Избегайте конструкции `new Array()`. Ключевое слово `new` только усложняет код.
Также, оно может привести к неожиданным результатам, используйте лучше литера массива `[]`
```javascript
let points = new Array(40, 100);  // Создается массив с двумя элементами (40 и 100)
let points = new Array(40);       // Создается массив с 40 элементами типа undefined!!!!!
```
### `Array.of()`
В `ES6` пришел новый метод. Разница между `Array.of()` и конструктором `Array` заключается в обработке 
целочисленных аргументов: `Array.of(7)` создаёт массив с одним элементом `7`, а `new Array(7)` создаёт пустой
массив со значением свойства `length` равным `7`
```js
Array.of(1);         // [1]
Array.of(1, 2, 3);   // [1, 2, 3]
Array.of(undefined); // [undefined]
```
## Как распознать массив?
В JavaScript для массивов оператор `typeof` возвращает тип "object", потому что в JS массив это объект.
Решить эту проблему может новый метод `Array.isArray()` из *ES5*
### `Array.isArray()`
Метод возвращает `true`, если объект является массивом и `false`, если он массивом не является.
```js
// Все следующие вызовы вернут true
Array.isArray([]);
Array.isArray([1]);
Array.isArray(new Array());
// Малоизвестный факт: Array.prototype сам является массивом:
Array.isArray(Array.prototype);
```
Другая проблема: ECMAScript 5 не поддерживается в старых браузерах. Тогда помогут следующие методы
```js
// Создаем собственную функцию 
function isArray(x) {
    return x.constructor.toString().indexOf("Array") > -1; // (1)
}
```

1. Эта функция всегда возвращает `true`, если в ее параметре передан массив. Вернее, она возвращает `true`, 
   если в прототипе объекта есть слово "Array".

Еще одно решение оператор `instanceof`
```js
let fruits = ["Банан", "Апельсин", "Яблоко", "Манго"];
fruits instanceof Array     // вернет true
```

##  Как создать массив из псевдомассива?
### `Array.from()`
Метод создаёт новый экземпляр `Array` из массивоподобного или итерируемого объекта.  
`Array.from(arrayLike, mapFn, thisArg)`

* `arrayLike` - Массивоподобный или итерируемый объект, преобразуемый в массив.
* `mapFn`(необязательный) - функция [`map`](/JavaScript/Array/sort_array/#arrmap) для каждого элемента создаваемого массива
* `thisArg`(необязательный) - Значение, используемое в качестве `this` при выполнении функции `mapFn`.

```JavaScript title="Массив из строки String"
Array.from('foo');
// ['f', 'o', 'o']
```
```JavaScript title="Array.from принимает объект, проверяет, является ли он итерируемым объектом, затем создаёт новый массив и копирует туда все элементы."
let arrayLike = {
    0: "Hello",
    1: "World",
    length: 2
};

let arr = Array.from(arrayLike); // ['Hello', 'World']
```
```js title="Массив из Set"
let s = new Set(['foo', window]);
Array.from(s); // ['foo', window]
```
```js title="Массив из Map"
var m = new Map([[1, 2], [2, 4], [4, 8]]);
Array.from(m); // [[1, 2], [2, 4], [4, 8]]
```
С использованием функции `map`
```JavaScript
// Использование стрелочной функции в качестве функции отображения для

// манипулирования элементами
Array.from([1, 2, 3], x => x + x);
// [2, 4, 6]

// Генерирования последовательности чисел
Array.from({ length: 5 }, (v, k) => k);
// [0, 1, 2, 3, 4]
```

## Добавление и удаление элементов
Четыре метода работающие с началом и концом массива.

=== "arr.push()"

    Добавляет один или более элементов в конец массива и возвращает новую длину массива
    ```JavaScript
    var sports = ['футбол', 'бейсбол'];
    var total = sports.push('американский футбол', 'плавание');

    console.log(sports); // ['футбол', 'бейсбол', 'американский футбол', 'плавание']
    console.log(total);  // 4
    ```

=== "arr.pop()"

    Удаляет **последний** элемент из массива и возвращает его значение. *Этот метод изменяет длину массива.*
    ```js
    var fruits = ["Банан", "Апельсин", "Яблоко", "Манго"];
    var x = fruits.pop();   // в переменной x будет строка "Манго"
    ```
    
=== "arr.unshift()"

    Добавляет один или более элементов в начало массива и возвращает новую длину массива.
    ```JavaScript
    let arr = [1, 2];

    arr.unshift(0); // результат вызова равен 3, новой длине массива
    // arr равен [0, 1, 2]

    arr.unshift(-2, -1); // = 5
    // arr равен [-2, -1, 0, 1, 2]

    arr.unshift([-3]); // = 6
    // arr равен[[-3], -2, -1, 0, 1, 2]
    ```

=== "arr.shift()"

    Удаляет **первый** элемент из массива и возвращает его значение.  
    *Этот метод изменяет длину массива.*
    Опасно применять данный метод если вы работаете с индексами элементов так, как `arr.shift()` **сдвигает значения по последовательным индексам вниз**.  
    Если массив пустой вернётся значение `undefined`.
    ```JavaScript
    var fruits = ["Банан", "Апельсин", "Яблоко", "Манго"];
    var x = fruits.shift();      // в переменной x будет строка "Банан"
    // fruits => ["Апельсин", "Яблоко", "Манго"];
    ```

### `delete`
Так как массивы – это объекты, то можно попробовать `delete`:
```js
let arr = ["I", "go", "home"];

delete arr[1]; // удалить "go"
arr[1] // undefined

// теперь arr = ["I",  , "home"];
```
Как мы видим из примера выше остаются дыры в массиве. Это нормально для объектов, но для массивов мы обычно хотим, 
чтобы оставшиеся элементы сдвинулись и заняли освободившееся место. Мы ждём, что массив станет короче.

### `arr.splice()`
Более универсальный метод изменяет содержимое массива, удаляя существующие элементы и/или добавляя новые. Возвращает массив, содержащий удалённые элементы, если никакие элементы не будут удалены, вернётся пустой массив.

```js title='Удаляет 0 элементов по индексу 2 и вставляет "drum"'
let myFish = ['angel', 'clown', 'mandarin', 'sturgeon'];
let removed = myFish.splice(2, 0, 'drum');

// myFish равен ["angel", "clown", "drum", "mandarin", "sturgeon"]
// removed равен [], ничего не удалено
```
```js title='Удаляет 1 элемент по индексу 3'
let myFish = ['angel', 'clown', 'drum', 'mandarin', 'sturgeon'];
let removed = myFish.splice(3, 1);

// removed равен ["mandarin"]
// myFish равен ["angel", "clown", "drum", "sturgeon"]
```
```js title='Удаляет 1 элемент по индексу 2 и вставляет "trumpet", как бы заменяя третий элемент'
let myFish = ['angel', 'clown', 'drum', 'sturgeon'];
let removed = myFish.splice(2, 1, 'trumpet');

// myFish равен ["angel", "clown", "trumpet", "sturgeon"]
// removed равен ["drum"]
```
```js title='Удаляет 1 элемент по индексу -2'
let myFish = ['angel', 'clown', 'mandarin', 'sturgeon'];
let removed = myFish.splice(-2, 1); // (1)

// myFish равен ["angel", "clown", "sturgeon"]
// removed равен s ["mandarin"]
```

1. Отрицательный индекс - указывает индекс элемента с конца.

```js title='Удаляет все элементы после индекса 2 (включительно)'
let myFish = ['angel', 'clown', 'mandarin', 'sturgeon'];
let removed = myFish.splice(2);

// myFish равен ["angel", "clown"]
// removed равен ["mandarin", "sturgeon"]
```
## Извлечение и копирование
### `arr.slice()`
Метод **не изменяет исходный массив**, а возвращает новую *«одноуровневую»* копию. Если элемент объект то копирует его ссылку в новый массив. И оригинал, и новый массив ссылаются на один и тот же объект. У строк и чисел копирует значения в новый массив. Если к любому массиву будет добавлен новый элемент, это никак не повлияет на другой массив.
```js 
// Пример: наши хорошие друзья цитрусовые среди фруктов
var fruits = ['Банан', 'Апельсин', 'Лимон', 'Яблоко', 'Манго'];
var citrus = fruits.slice(1, 3);

// citrus содержит ['Апельсин', 'Лимон']
```
```js 
// Используя slice, создаём newCar из myCar.
var myHonda = { color: 'красный', wheels: 4, engine: { cylinders: 4, size: 2.2 } };
var myCar = [myHonda, 2, 'в хорошем состоянии', 'приобретена в 1997'];
var newCar = myCar.slice(0, 2); // [myHonda, 2]
// Теперь оба массива ссылаются на один объект
newCar[0] === myCar[0] // true 
```
```js title="Можно скопировать весь массив"
let arr = ["t", "e", "s", "t"];
let newArr = arr.slice() // ["t", "e", "s", "t"]
newArr === arr // false 
```

## Слияние массивов
### `arr.concat()`
Метод **возвращает новый массив**, состоящий из массива, на котором он был вызван, соединённого с другими массивами, переданными в качестве аргументов.

Как и метод `slice()` не изменяет данный массив или любой из массивов, переданных в аргументах, а вместо этого возвращает поверхностную копию.
```JavaScript
let alpha = ['a', 'b', 'c'],
    numeric = [1, 2, 3];

let alphaNumeric = alpha.concat(numeric);

console.log(alphaNumeric); // Результат: ['a', 'b', 'c', 1, 2, 3]
```
```JavaScript
var alpha = ['a', 'b', 'c'];
var alphaNumeric = alpha.concat(1, [2, 3]);

console.log(alphaNumeric); // Результат: ['a', 'b', 'c', 1, 2, 3]
```

## Преобразование массива в строку и обратно
### `arr.toString()`
JavaScript вызывает метод `toString` автоматически, когда массив представляется текстовым значением или когда массив находится в контексте конкатенации строк.
```js 
let monthNames = ['Янв', 'Фев', 'Мар', 'Апр'];
let myVar = monthNames.toString(); // присваивает 'Янв,Фев,Мар,Апр' переменной myVar.
```
### `arr.join()`
Метод объединяет все элементы массива (или массивоподобного объекта) в строку. Он действует как метод `toString()`, но при этом позволяет указать разделитель:
```js 
var a = ['Ветер', 'Дождь', 'Огонь'];
var myVar1 = a.join();      // присвоит 'Ветер,Дождь,Огонь'
var myVar2 = a.join(', ');  // присвоит 'Ветер, Дождь, Огонь'
var myVar3 = a.join(' + '); // присвоит 'Ветер + Дождь + Огонь'
var myVar4 = a.join('');    // присвоит 'ВетерДождьОгонь'
```
А как обратно ? из Строки в Массив. Метод `str.split('разделитель')` именно это и делает. Он разбивает строку на массив по заданному разделителю.
