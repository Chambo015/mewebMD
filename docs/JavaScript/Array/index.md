# Array
## Как лучше создавать массив?
Избегайте конструкции `new Array()`. Ключевое слово `new` только усложняет код.
Также, оно может привести к неожиданным результатам
```js
let points = new Array(40, 100);  // Создается массив с двумя элементами (40 и 100)
let points = new Array(40);       // Создается массив с 40 элементами типа undefined!!!!!
```
### `Array.of()`
В `ES6` пришел новый метод. Разница между `Array.of()` и конструктором `Array` заключается в обработке 
целочисленных аргументов: `Array.of(7)` создаёт массив с одним элементом `7`, а `Array(7)` создаёт пустой
массив со значением свойства `length` равным `7`
```js
Array.of(1);         // [1]
Array.of(1, 2, 3);   // [1, 2, 3]
Array.of(undefined); // [undefined]
```
## Как распознать массив?
В JavaScript для массивов оператор `typeof` возвращает тип "object", потому что в JS массив это объект.
Решить эту проблему может новый метод `Array.isArray()` из *ES5*
### `Array.isArray()`
Метод возвращает `true`, если объект является массивом и `false`, если он массивом не является.
```js
// Все следующие вызовы вернут true
Array.isArray([]);
Array.isArray([1]);
Array.isArray(new Array());
// Малоизвестный факт: Array.prototype сам является массивом:
Array.isArray(Array.prototype);
```
Другая проблема: ECMAScript 5 не поддерживается в старых браузерах. Тогда помогут следующие методы
```js
// Создаем собственную функцию 
function isArray(x) {
    return x.constructor.toString().indexOf("Array") > -1; // (1)
}
```

1. Эта функция всегда возвращает `true`, если в ее параметре передан массив. Вернее, она возвращает `true`, 
   если в прототипе объекта есть слово "Array".

Еще одно решение оператор `instanceof`
```js
var fruits = ["Банан", "Апельсин", "Яблоко", "Манго"];

fruits instanceof Array     // вернет true
```